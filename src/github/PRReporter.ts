import * as core from '@actions/core';
import { VerificationResult } from '../types';
import { getGitHubCommentEngine, errorHandler, ErrorCategory, ErrorSeverity } from '../core';
import { GitHubServiceFactory } from '../core/github/GitHubServiceFactory';

/**
 * PR Reporter - Now uses centralized GitHub comment engine
 * @deprecated Use GitHubCommentEngine directly for new code
 */
export class PRReporter {
  private commentEngine = getGitHubCommentEngine();
  private prNumber: number;

  constructor() {
    // Comment engine is already initialized globally
    // Use GitHubServiceFactory to get context
    const githubService = GitHubServiceFactory.getService();
    const context = githubService.getContext();
    this.prNumber = context.prNumber || 0;

    if (!this.prNumber) {
      core.warning('No PR number found, cannot post comment');
    }
  }

  /**
   * Post comprehensive verification results to PR
   */
  async postResults(result: VerificationResult, storageConsoleUrl?: string): Promise<void> {
    if (!this.prNumber) {
      core.warning('No PR number found, cannot post comment');
      return;
    }
    
    try {
      core.info(`Posting verification results to PR #${this.prNumber}...`);
      
      const comment = this.generateCommentBody(result, storageConsoleUrl);
      
      await this.commentEngine.postComment(comment, {
        updateExisting: true,
        signature: 'yofix-verification-results'
      });
      
      core.info('Posted verification results to PR');
    } catch (error) {
      await errorHandler.handleError(error as Error, {
        severity: ErrorSeverity.HIGH,
        category: ErrorCategory.UNKNOWN,
        userAction: 'Post verification results to PR',
        metadata: { prNumber: this.prNumber }
      });
      throw error;
    }
  }

  /**
   * Post a simple status update (for early failures)
   */
  async postStatusUpdate(status: 'running' | 'failed' | 'skipped', message: string): Promise<void> {
    if (!this.prNumber) {
      core.warning('No PR number found, cannot post status update');
      return;
    }
    
    try {
      const statusEmoji = {
        running: 'üîÑ',
        failed: '‚ùå',
        skipped: '‚è≠Ô∏è'
      };

      const comment = `## ${statusEmoji[status]} Runtime PR Verification

**Status**: ${status.charAt(0).toUpperCase() + status.slice(1)}

${message}

---
*Generated by [YoFix](https://github.com/yofix/yofix) ‚Ä¢ ${new Date().toLocaleString()}*`;

      await this.commentEngine.postComment(comment, {
        updateExisting: true,
        signature: 'yofix-status-update'
      });
    } catch (error) {
      await errorHandler.handleError(error as Error, {
        severity: ErrorSeverity.MEDIUM,
        category: ErrorCategory.UNKNOWN,
        userAction: 'Post status update to PR',
        metadata: { status, prNumber: this.prNumber },
        recoverable: true
      });
    }
  }

  /**
   * Generate comprehensive comment body with React-specific results
   */
  private generateCommentBody(result: VerificationResult, storageConsoleUrl?: string): string {
    const statusEmoji = result.status === 'success' ? '‚úÖ' : result.status === 'partial' ? '‚ö†Ô∏è' : '‚ùå';
    const firebaseEmoji = 'üî•';
    const reactEmoji = '‚öõÔ∏è';
    
    // Header with overall status
    let comment = `## ${statusEmoji} Runtime PR Verification - React SPA

**Status**: ${result.status.charAt(0).toUpperCase() + result.status.slice(1)} | `;
    comment += `${reactEmoji} React ${result.firebaseConfig.buildSystem === 'vite' ? 'Vite' : 'CRA'} | `;
    comment += `${firebaseEmoji} Firebase ${result.firebaseConfig.target}\n\n`;

    // Test summary
    comment += `**Test Results**: ${result.passedTests}/${result.totalTests} passed`;
    if (result.failedTests > 0) {
      comment += ` ‚Ä¢ ${result.failedTests} failed`;
    }
    if (result.skippedTests > 0) {
      comment += ` ‚Ä¢ ${result.skippedTests} skipped`;
    }
    comment += ` ‚Ä¢ ${this.formatDuration(result.duration)}\n\n`;

    // Quick access links
    const screenshots = result.testResults.flatMap(t => t.screenshots);
    const videos = result.testResults.flatMap(t => t.videos);
    
    if (screenshots.length > 0 || videos.length > 0) {
      comment += `**Visual Evidence**: `;
      comment += `üì∏ ${screenshots.length} screenshot${screenshots.length !== 1 ? 's' : ''}`;
      if (videos.length > 0) {
        comment += ` ‚Ä¢ üé• ${videos.length} video${videos.length !== 1 ? 's' : ''}`;
      }
      if (storageConsoleUrl) {
        comment += ` ‚Ä¢ [Firebase Console](${storageConsoleUrl})`;
      }
      comment += '\n\n';
    }

    // Embed screenshots directly
    if (screenshots.length > 0) {
      core.info(`Embedding ${screenshots.length} screenshots in PR comment`);
      const screenshotsWithUrls = screenshots.filter(s => s.firebaseUrl);
      core.info(`Screenshots with Firebase URLs: ${screenshotsWithUrls.length}`);
      
      comment += this.generateEmbeddedScreenshots(screenshots);
    }
    
    // Embed videos directly
    if (videos.length > 0) {
      core.info(`Embedding ${videos.length} videos in PR comment`);
      const videosWithUrls = videos.filter(v => v.firebaseUrl);
      core.info(`Videos with Firebase URLs: ${videosWithUrls.length}`);
      
      comment += this.generateEmbeddedVideos(videos);
    }


    // Expandable details section
    comment += '<details>\n<summary><strong>View Detailed Results</strong></summary>\n\n';

    // Components and routes verified
    if (result.summary.componentsVerified.length > 0 || result.summary.routesTested.length > 0) {
      comment += '### ‚úÖ React App Verification\n\n';
      
      if (result.summary.componentsVerified.length > 0) {
        comment += `**Components Tested**: ${result.summary.componentsVerified.join(', ')}\n\n`;
      }
      
      if (result.summary.routesTested.length > 0) {
        comment += `**Routes Verified**: ${result.summary.routesTested.join(', ')}\n\n`;
      }
    }

    // Individual test results
    comment += '### üìã Test Results\n\n';
    
    for (const test of result.testResults) {
      const testEmoji = test.status === 'passed' ? '‚úÖ' : test.status === 'failed' ? '‚ùå' : '‚è≠Ô∏è';
      comment += `${testEmoji} **${test.testName}** (${this.formatDuration(test.duration)})\n`;
      
      if (test.errors.length > 0) {
        comment += `   - ‚ö†Ô∏è Issues: ${test.errors.slice(0, 2).join(', ')}`;
        if (test.errors.length > 2) {
          comment += ` and ${test.errors.length - 2} more`;
        }
        comment += '\n';
      }
      
      if (test.screenshots.length > 0) {
        comment += '   - üì∏ Screenshots captured for: ';
        comment += test.screenshots.map(s => s.viewport.name).join(', ') + '\n';
      }
      
      if (test.videos.length > 0 && test.videos[0]?.firebaseUrl) {
        comment += `   - üé• Video: [View Recording](${test.videos[0].firebaseUrl})\n`;
      }
      
      comment += '\n';
    }

    // Issues found section
    if (result.summary.issuesFound.length > 0) {
      comment += '### ‚ö†Ô∏è Issues Detected\n\n';
      for (const issue of result.summary.issuesFound.slice(0, 5)) {
        comment += `- ${issue}\n`;
      }
      if (result.summary.issuesFound.length > 5) {
        comment += `- ...and ${result.summary.issuesFound.length - 5} more issues\n`;
      }
      comment += '\n';
    }

    // Firebase configuration details
    comment += '### üî• Firebase Configuration\n\n';
    comment += `- **Project**: \`${result.firebaseConfig.projectId}\`\n`;
    comment += `- **Target**: \`${result.firebaseConfig.target}\`\n`;
    comment += `- **Build System**: ${result.firebaseConfig.buildSystem === 'vite' ? 'Vite' : 'Create React App'}\n`;
    comment += `- **Preview URL**: [${result.firebaseConfig.previewUrl}](${result.firebaseConfig.previewUrl})\n\n`;

    // Performance metrics
    const consoleErrors = result.testResults.flatMap(t => 
      t.consoleMessages.filter(m => m.type === 'error')
    );
    
    if (consoleErrors.length > 0) {
      comment += '### üêõ Console Errors\n\n';
      comment += `Found ${consoleErrors.length} console error${consoleErrors.length !== 1 ? 's' : ''} during testing:\n\n`;
      for (const error of consoleErrors.slice(0, 3)) {
        comment += `- \`${error.text.substring(0, 100)}${error.text.length > 100 ? '...' : ''}\`\n`;
      }
      if (consoleErrors.length > 3) {
        comment += `- ...and ${consoleErrors.length - 3} more errors\n`;
      }
      comment += '\n';
    }

    comment += '</details>\n\n';

    // Footer
    const timestamp = new Date().toLocaleString();
    comment += `---\n*Generated by [YoFix](https://github.com/yofix/yofix) ‚Ä¢ ${timestamp}*`;

    return comment;
  }

  /**
   * Format duration in human-readable format
   */
  private formatDuration(durationMs: number): string {
    if (durationMs < 1000) {
      return `${durationMs}ms`;
    } else if (durationMs < 60000) {
      return `${(durationMs / 1000).toFixed(1)}s`;
    } else {
      const minutes = Math.floor(durationMs / 60000);
      const seconds = ((durationMs % 60000) / 1000).toFixed(0);
      return `${minutes}m ${seconds}s`;
    }
  }

  /**
   * Generate embedded screenshots for PR comment
   */
  private generateEmbeddedScreenshots(screenshots: any[]): string {
    if (screenshots.length === 0) {
      return '';
    }

    let gallery = '### üì∏ Screenshots\n\n';
    
    // Group screenshots by test/route name (remove viewport info)
    const groupedByRoute = screenshots.reduce((acc, screenshot) => {
      // Extract route from screenshot name by removing viewport dimensions
      let route = screenshot.name;
      // Remove viewport size pattern (e.g., -1920x1080)
      route = route.replace(/-\d+x\d+$/, '');
      // Clean up the route name
      route = route.replace(/^\//, '').replace(/-/g, ' ');
      
      if (!acc[route]) {
        acc[route] = [];
      }
      acc[route].push(screenshot);
      return acc;
    }, {} as Record<string, any[]>);

    // Generate gallery for each route
    for (const [route, routeScreenshots] of Object.entries(groupedByRoute)) {
      gallery += `#### Route: \`${route}\`\n\n`;
      
      // Only show images if they have Firebase URLs
      const screenshotsWithUrls = (routeScreenshots as any[]).filter((s: any) => s.firebaseUrl);
      
      if (screenshotsWithUrls.length === 0) {
        gallery += `_Screenshots captured but URLs not available_\n\n`;
        continue;
      }
      
      // Create a table for viewports
      gallery += '<table>\n<tr>\n';
      
      // Sort by viewport size (desktop, tablet, mobile)
      const sorted = screenshotsWithUrls.sort((a, b) => b.viewport.width - a.viewport.width);
      
      for (const screenshot of sorted) {
        gallery += `<td align="center">\n`;
        gallery += `<strong>${screenshot.viewport.name}</strong><br>\n`;
        gallery += `${screenshot.viewport.width}√ó${screenshot.viewport.height}<br>\n`;
        gallery += `<img src="${screenshot.firebaseUrl}" width="300" alt="${screenshot.name}" />\n`;
        gallery += `</td>\n`;
      }
      
      gallery += '</tr>\n</table>\n\n';
    }

    return gallery;
  }

  /**
   * Generate embedded videos for PR comment
   */
  private generateEmbeddedVideos(videos: any[]): string {
    if (videos.length === 0) {
      return '';
    }

    let gallery = '### üé• Test Videos\n\n';
    
    // Only show videos that have Firebase URLs
    const videosWithUrls = videos.filter(v => v.firebaseUrl);
    
    if (videosWithUrls.length === 0) {
      gallery += '_Videos captured but URLs not available_\n\n';
      return gallery;
    }
    
    // GitHub doesn't support video embedding, so we'll create nice preview links
    // with video thumbnails if possible
    gallery += '<table>\n';
    
    // Create rows of 3 videos each
    for (let i = 0; i < videosWithUrls.length; i += 3) {
      gallery += '<tr>\n';
      
      for (let j = i; j < Math.min(i + 3, videosWithUrls.length); j++) {
        const video = videosWithUrls[j];
        gallery += `<td align="center" width="33%">\n`;
        gallery += `<a href="${video.firebaseUrl}">\n`;
        // Use a play button emoji as a visual indicator
        gallery += `<div>üé¨</div>\n`;
        gallery += `<strong>${video.name.replace(/\.(webm|mp4)$/, '')}</strong><br>\n`;
        gallery += `<em>${this.formatDuration(video.duration)}</em><br>\n`;
        gallery += `<kbd>‚ñ∂Ô∏è Click to Play</kbd>\n`;
        gallery += `</a>\n`;
        gallery += `</td>\n`;
      }
      
      // Fill empty cells if needed
      for (let k = videosWithUrls.length % 3; k < 3 && k > 0 && i + 3 > videosWithUrls.length; k++) {
        gallery += `<td></td>\n`;
      }
      
      gallery += '</tr>\n';
    }
    
    gallery += '</table>\n\n';
    
    // Add direct links as well
    gallery += '<details>\n<summary>Direct video links</summary>\n\n';
    for (const video of videosWithUrls) {
      gallery += `- [${video.name}](${video.firebaseUrl}) - ${this.formatDuration(video.duration)}\n`;
    }
    gallery += '\n</details>\n\n';

    return gallery;
  }

  /**
   * Generate compact status badge for quick overview
   */
  generateStatusBadge(result: VerificationResult): string {
    const status = result.status;
    const color = status === 'success' ? 'brightgreen' : status === 'partial' ? 'yellow' : 'red';
    const tests = `${result.passedTests}/${result.totalTests}`;
    
    return `![Tests](https://img.shields.io/badge/tests-${tests}-${color}) ![Status](https://img.shields.io/badge/status-${status}-${color})`;
  }
}