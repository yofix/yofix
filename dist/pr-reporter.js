"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PRReporter = void 0;
const core = __importStar(require("@actions/core"));
const github_1 = require("@actions/github");
class PRReporter {
    constructor(githubToken) {
        this.octokit = (0, github_1.getOctokit)(githubToken);
        const context = require('@actions/github').context;
        this.owner = context.repo.owner;
        this.repo = context.repo.repo;
        this.prNumber = context.payload.pull_request?.number;
        if (!this.prNumber) {
            throw new Error('No pull request number found in context');
        }
    }
    async postResults(result, storageConsoleUrl) {
        core.info(`Posting verification results to PR #${this.prNumber}...`);
        try {
            const comment = this.generateCommentBody(result, storageConsoleUrl);
            const existingComment = await this.findExistingComment();
            if (existingComment) {
                await this.octokit.rest.issues.updateComment({
                    owner: this.owner,
                    repo: this.repo,
                    comment_id: existingComment.id,
                    body: comment
                });
                core.info('Updated existing PR comment');
            }
            else {
                await this.octokit.rest.issues.createComment({
                    owner: this.owner,
                    repo: this.repo,
                    issue_number: this.prNumber,
                    body: comment
                });
                core.info('Created new PR comment');
            }
        }
        catch (error) {
            core.error(`Failed to post PR comment: ${error}`);
            throw error;
        }
    }
    async postStatusUpdate(status, message) {
        try {
            const statusEmoji = {
                running: 'ðŸ”„',
                failed: 'âŒ',
                skipped: 'â­ï¸'
            };
            const comment = `## ${statusEmoji[status]} Runtime PR Verification

**Status**: ${status.charAt(0).toUpperCase() + status.slice(1)}

${message}

---
*Generated by [Runtime PR Verification](https://github.com/your-org/runtime-pr-verification) â€¢ ${new Date().toLocaleString()}*`;
            const existingComment = await this.findExistingComment();
            if (existingComment) {
                await this.octokit.rest.issues.updateComment({
                    owner: this.owner,
                    repo: this.repo,
                    comment_id: existingComment.id,
                    body: comment
                });
            }
            else {
                await this.octokit.rest.issues.createComment({
                    owner: this.owner,
                    repo: this.repo,
                    issue_number: this.prNumber,
                    body: comment
                });
            }
        }
        catch (error) {
            core.warning(`Failed to post status update: ${error}`);
        }
    }
    generateCommentBody(result, storageConsoleUrl) {
        const statusEmoji = result.status === 'success' ? 'âœ…' : result.status === 'partial' ? 'âš ï¸' : 'âŒ';
        const firebaseEmoji = 'ðŸ”¥';
        const reactEmoji = 'âš›ï¸';
        let comment = `## ${statusEmoji} Runtime PR Verification - React SPA

**Status**: ${result.status.charAt(0).toUpperCase() + result.status.slice(1)} | `;
        comment += `${reactEmoji} React ${result.firebaseConfig.buildSystem === 'vite' ? 'Vite' : 'CRA'} | `;
        comment += `${firebaseEmoji} Firebase ${result.firebaseConfig.target}\n\n`;
        comment += `**Test Results**: ${result.passedTests}/${result.totalTests} passed`;
        if (result.failedTests > 0) {
            comment += ` â€¢ ${result.failedTests} failed`;
        }
        if (result.skippedTests > 0) {
            comment += ` â€¢ ${result.skippedTests} skipped`;
        }
        comment += ` â€¢ ${this.formatDuration(result.duration)}\n\n`;
        const screenshots = result.testResults.flatMap(t => t.screenshots);
        const videos = result.testResults.flatMap(t => t.videos);
        if (screenshots.length > 0 || videos.length > 0) {
            comment += `**Visual Evidence**: `;
            comment += `ðŸ“¸ ${screenshots.length} screenshot${screenshots.length !== 1 ? 's' : ''}`;
            if (videos.length > 0) {
                comment += ` â€¢ ðŸŽ¥ ${videos.length} video${videos.length !== 1 ? 's' : ''}`;
            }
            if (storageConsoleUrl) {
                comment += ` â€¢ [Firebase Console](${storageConsoleUrl})`;
            }
            comment += '\n\n';
        }
        if (screenshots.length > 0) {
            comment += this.generateEmbeddedScreenshots(screenshots);
        }
        comment += '<details>\n<summary><strong>View Detailed Results</strong></summary>\n\n';
        if (result.summary.componentsVerified.length > 0 || result.summary.routesTested.length > 0) {
            comment += '### âœ… React App Verification\n\n';
            if (result.summary.componentsVerified.length > 0) {
                comment += `**Components Tested**: ${result.summary.componentsVerified.join(', ')}\n\n`;
            }
            if (result.summary.routesTested.length > 0) {
                comment += `**Routes Verified**: ${result.summary.routesTested.join(', ')}\n\n`;
            }
        }
        comment += '### ðŸ“‹ Test Results\n\n';
        for (const test of result.testResults) {
            const testEmoji = test.status === 'passed' ? 'âœ…' : test.status === 'failed' ? 'âŒ' : 'â­ï¸';
            comment += `${testEmoji} **${test.testName}** (${this.formatDuration(test.duration)})\n`;
            if (test.errors.length > 0) {
                comment += `   - âš ï¸ Issues: ${test.errors.slice(0, 2).join(', ')}`;
                if (test.errors.length > 2) {
                    comment += ` and ${test.errors.length - 2} more`;
                }
                comment += '\n';
            }
            if (test.screenshots.length > 0) {
                comment += '   - ðŸ“¸ Screenshots captured for: ';
                comment += test.screenshots.map(s => s.viewport.name).join(', ') + '\n';
            }
            if (test.videos.length > 0 && test.videos[0]?.firebaseUrl) {
                comment += `   - ðŸŽ¥ Video: [View Recording](${test.videos[0].firebaseUrl})\n`;
            }
            comment += '\n';
        }
        if (result.summary.issuesFound.length > 0) {
            comment += '### âš ï¸ Issues Detected\n\n';
            for (const issue of result.summary.issuesFound.slice(0, 5)) {
                comment += `- ${issue}\n`;
            }
            if (result.summary.issuesFound.length > 5) {
                comment += `- ...and ${result.summary.issuesFound.length - 5} more issues\n`;
            }
            comment += '\n';
        }
        comment += '### ðŸ”¥ Firebase Configuration\n\n';
        comment += `- **Project**: \`${result.firebaseConfig.projectId}\`\n`;
        comment += `- **Target**: \`${result.firebaseConfig.target}\`\n`;
        comment += `- **Build System**: ${result.firebaseConfig.buildSystem === 'vite' ? 'Vite' : 'Create React App'}\n`;
        comment += `- **Preview URL**: [${result.firebaseConfig.previewUrl}](${result.firebaseConfig.previewUrl})\n\n`;
        const consoleErrors = result.testResults.flatMap(t => t.consoleMessages.filter(m => m.type === 'error'));
        if (consoleErrors.length > 0) {
            comment += '### ðŸ› Console Errors\n\n';
            comment += `Found ${consoleErrors.length} console error${consoleErrors.length !== 1 ? 's' : ''} during testing:\n\n`;
            for (const error of consoleErrors.slice(0, 3)) {
                comment += `- \`${error.text.substring(0, 100)}${error.text.length > 100 ? '...' : ''}\`\n`;
            }
            if (consoleErrors.length > 3) {
                comment += `- ...and ${consoleErrors.length - 3} more errors\n`;
            }
            comment += '\n';
        }
        comment += '</details>\n\n';
        const timestamp = new Date().toLocaleString();
        comment += `---\n*Generated by [Runtime PR Verification](https://github.com/your-org/runtime-pr-verification) â€¢ ${timestamp}*`;
        return comment;
    }
    async findExistingComment() {
        try {
            const comments = await this.octokit.rest.issues.listComments({
                owner: this.owner,
                repo: this.repo,
                issue_number: this.prNumber,
                per_page: 100
            });
            const existingComment = comments.data.find(comment => comment.body?.includes('Runtime PR Verification') &&
                comment.body?.includes('Generated by') &&
                comment.user?.type === 'Bot');
            return existingComment ? { id: existingComment.id } : null;
        }
        catch (error) {
            core.warning(`Failed to find existing comment: ${error}`);
            return null;
        }
    }
    formatDuration(durationMs) {
        if (durationMs < 1000) {
            return `${durationMs}ms`;
        }
        else if (durationMs < 60000) {
            return `${(durationMs / 1000).toFixed(1)}s`;
        }
        else {
            const minutes = Math.floor(durationMs / 60000);
            const seconds = ((durationMs % 60000) / 1000).toFixed(0);
            return `${minutes}m ${seconds}s`;
        }
    }
    generateEmbeddedScreenshots(screenshots) {
        if (screenshots.length === 0) {
            return '';
        }
        let gallery = '### ðŸ“¸ Screenshots\n\n';
        const groupedByRoute = screenshots.reduce((acc, screenshot) => {
            const route = screenshot.name.split('-').slice(0, -1).join('-') || 'home';
            if (!acc[route]) {
                acc[route] = [];
            }
            acc[route].push(screenshot);
            return acc;
        }, {});
        for (const [route, routeScreenshots] of Object.entries(groupedByRoute)) {
            gallery += `#### Route: \`/${route}\`\n\n`;
            gallery += '<table>\n<tr>\n';
            const sorted = routeScreenshots.sort((a, b) => b.viewport.width - a.viewport.width);
            for (const screenshot of sorted) {
                if (screenshot.firebaseUrl) {
                    gallery += `<td align="center">\n`;
                    gallery += `<strong>${screenshot.viewport.name}</strong><br>\n`;
                    gallery += `${screenshot.viewport.width}Ã—${screenshot.viewport.height}<br>\n`;
                    gallery += `<img src="${screenshot.firebaseUrl}" width="300" alt="${screenshot.name}">\n`;
                    gallery += `</td>\n`;
                }
            }
            gallery += '</tr>\n</table>\n\n';
        }
        return gallery;
    }
    generateStatusBadge(result) {
        const status = result.status;
        const color = status === 'success' ? 'brightgreen' : status === 'partial' ? 'yellow' : 'red';
        const tests = `${result.passedTests}/${result.totalTests}`;
        return `![Tests](https://img.shields.io/badge/tests-${tests}-${color}) ![Status](https://img.shields.io/badge/status-${status}-${color})`;
    }
}
exports.PRReporter = PRReporter;
