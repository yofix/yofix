/// <reference types="jest" />

import { RouteImpactAnalyzer } from '../RouteImpactAnalyzer';
import { GitHubServiceFactory, MockGitHubService } from '../../github/GitHubServiceFactory';
import * as fs from 'fs';
import * as path from 'path';

// Mock dependencies
jest.mock('fs');

// Mock tree-sitter modules - these need to be mocked before importing the module under test
jest.mock('tree-sitter');
jest.mock('tree-sitter-typescript');
jest.mock('tree-sitter-javascript');

describe('RouteImpactAnalyzer', () => {
  let analyzer: RouteImpactAnalyzer;
  let mockService: MockGitHubService;

  beforeEach(() => {
    // Reset factory and set up mock service
    GitHubServiceFactory.reset();
    mockService = new MockGitHubService();
    GitHubServiceFactory.setService(mockService);
    
    // Configure mock service
    mockService.configure({
      token: 'test-token',
      owner: 'test-owner',
      repo: 'test-repo'
    });
    
    // Set up mock context
    mockService.setMockContext({
      owner: 'test-owner',
      repo: 'test-repo',
      prNumber: 123
    });
    
    analyzer = new RouteImpactAnalyzer();
  });
  
  afterEach(() => {
    GitHubServiceFactory.reset();
  });

  describe('formatImpactTree', () => {
    it('should format empty tree correctly', () => {
      const tree = {
        affectedRoutes: [],
        sharedComponents: new Map(),
        totalFilesChanged: 0,
        totalRoutesAffected: 0
      };

      const result = analyzer.formatImpactTree(tree);
      expect(result).toBe('✅ No routes affected by changes in this PR');
    });

    it('should format single route impact', () => {
      const tree = {
        affectedRoutes: [{
          route: '/',
          directChanges: ['pages/index.tsx'],
          componentChanges: ['components/Header.tsx'],
          styleChanges: ['styles/global.css'],
          sharedComponents: []
        }],
        sharedComponents: new Map(),
        totalFilesChanged: 3,
        totalRoutesAffected: 1
      };

      const result = analyzer.formatImpactTree(tree);
      expect(result).toContain('Route Tree:');
      expect(result).toContain('└── /');
      expect(result).toContain('index.tsx (route file)');
      expect(result).toContain('Header.tsx (component)');
      expect(result).toContain('global.css (styles)');
    });

    it('should show shared components warning', () => {
      const sharedMap = new Map([
        ['components/Button.tsx', ['/', '/products', '/checkout']]
      ]);

      const tree = {
        affectedRoutes: [
          {
            route: '/',
            directChanges: [],
            componentChanges: ['components/Button.tsx'],
            styleChanges: [],
            sharedComponents: ['components/Button.tsx']
          },
          {
            route: '/products',
            directChanges: [],
            componentChanges: ['components/Button.tsx'],
            styleChanges: [],
            sharedComponents: ['components/Button.tsx']
          }
        ],
        sharedComponents: sharedMap,
        totalFilesChanged: 1,
        totalRoutesAffected: 2
      };

      const result = analyzer.formatImpactTree(tree);
      expect(result).toContain('⚠️ **Shared Components**');
      expect(result).toContain('`Button.tsx` → affects `/`, `/products`');
      expect(result).toContain('(shared component)');
    });

    it('should format multiple routes with proper tree structure', () => {
      const tree = {
        affectedRoutes: [
          {
            route: '/',
            directChanges: ['pages/index.tsx'],
            componentChanges: [],
            styleChanges: [],
            sharedComponents: []
          },
          {
            route: '/products',
            directChanges: [],
            componentChanges: ['components/ProductCard.tsx'],
            styleChanges: [],
            sharedComponents: []
          },
          {
            route: '/checkout',
            directChanges: ['pages/checkout.tsx'],
            componentChanges: [],
            styleChanges: ['styles/checkout.css'],
            sharedComponents: []
          }
        ],
        sharedComponents: new Map(),
        totalFilesChanged: 4,
        totalRoutesAffected: 3
      };

      const result = analyzer.formatImpactTree(tree);
      expect(result).toContain('├── /');
      expect(result).toContain('├── /products');
      expect(result).toContain('└── /checkout');
      expect(result).toContain('├── checkout.tsx (route file)');
      expect(result).toContain('└── checkout.css (styles)');
    });
  });

  describe('analyzePRImpact', () => {
    it('should handle PR with no changed files', async () => {
      // Set up mock to return no files
      mockService.setMockPRFiles('test-owner', 'test-repo', 123, []);

      // Mock file system
      (fs.existsSync as jest.Mock).mockReturnValue(false);

      const result = await analyzer.analyzePRImpact(123);
      
      expect(result.totalFilesChanged).toBe(0);
      expect(result.affectedRoutes).toHaveLength(0);
    });

    it('should detect route file changes', async () => {
      // Set up mock PR files
      mockService.setMockPRFiles('test-owner', 'test-repo', 123, [
        { filename: 'pages/index.tsx', status: 'modified', additions: 5, deletions: 2, changes: 7 },
        { filename: 'pages/products/index.tsx', status: 'added', additions: 50, deletions: 0, changes: 50 }
      ]);

      // Mock codebase structure
      const mockRoutes = [
        { path: '/', file: 'pages/index.tsx', component: 'HomePage' },
        { path: '/products', file: 'pages/products/index.tsx', component: 'ProductsPage' }
      ];

      // This would need more mocking of CodebaseAnalyzer
      // For now, just verify the structure and that it can call the GitHub service
      expect(analyzer).toBeDefined();
      
      // Verify that the mock service can be called
      const files = await mockService.listPullRequestFiles('test-owner', 'test-repo', 123);
      expect(files).toHaveLength(2);
      expect(files[0].filename).toBe('pages/index.tsx');
    });
  });
});