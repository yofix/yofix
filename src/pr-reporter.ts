import * as core from '@actions/core';
import { getOctokit } from '@actions/github';
import { VerificationResult, TestResult, Screenshot, Video, FirebaseConfig } from './types';

export class PRReporter {
  private octokit: ReturnType<typeof getOctokit>;
  private prNumber: number;
  private owner: string;
  private repo: string;

  constructor(githubToken: string) {
    this.octokit = getOctokit(githubToken);
    
    const context = require('@actions/github').context;
    this.owner = context.repo.owner;
    this.repo = context.repo.repo;
    this.prNumber = context.payload.pull_request?.number;

    if (!this.prNumber) {
      throw new Error('No pull request number found in context');
    }
  }

  /**
   * Post comprehensive verification results to PR
   */
  async postResults(result: VerificationResult, storageConsoleUrl?: string): Promise<void> {
    core.info(`Posting verification results to PR #${this.prNumber}...`);

    try {
      const comment = this.generateCommentBody(result, storageConsoleUrl);
      
      // Check if we already have a comment from this action
      const existingComment = await this.findExistingComment();
      
      if (existingComment) {
        // Update existing comment
        await this.octokit.rest.issues.updateComment({
          owner: this.owner,
          repo: this.repo,
          comment_id: existingComment.id,
          body: comment
        });
        core.info('Updated existing PR comment');
      } else {
        // Create new comment
        await this.octokit.rest.issues.createComment({
          owner: this.owner,
          repo: this.repo,
          issue_number: this.prNumber,
          body: comment
        });
        core.info('Created new PR comment');
      }
    } catch (error) {
      core.error(`Failed to post PR comment: ${error}`);
      throw error;
    }
  }

  /**
   * Post a simple status update (for early failures)
   */
  async postStatusUpdate(status: 'running' | 'failed' | 'skipped', message: string): Promise<void> {
    try {
      const statusEmoji = {
        running: 'ðŸ”„',
        failed: 'âŒ',
        skipped: 'â­ï¸'
      };

      const comment = `## ${statusEmoji[status]} Runtime PR Verification

**Status**: ${status.charAt(0).toUpperCase() + status.slice(1)}

${message}

---
*Generated by [Runtime PR Verification](https://github.com/your-org/runtime-pr-verification) â€¢ ${new Date().toLocaleString()}*`;

      const existingComment = await this.findExistingComment();
      
      if (existingComment) {
        await this.octokit.rest.issues.updateComment({
          owner: this.owner,
          repo: this.repo,
          comment_id: existingComment.id,
          body: comment
        });
      } else {
        await this.octokit.rest.issues.createComment({
          owner: this.owner,
          repo: this.repo,
          issue_number: this.prNumber,
          body: comment
        });
      }
    } catch (error) {
      core.warning(`Failed to post status update: ${error}`);
    }
  }

  /**
   * Generate comprehensive comment body with React-specific results
   */
  private generateCommentBody(result: VerificationResult, storageConsoleUrl?: string): string {
    const statusEmoji = result.status === 'success' ? 'âœ…' : result.status === 'partial' ? 'âš ï¸' : 'âŒ';
    const firebaseEmoji = 'ðŸ”¥';
    const reactEmoji = 'âš›ï¸';
    
    // Header with overall status
    let comment = `## ${statusEmoji} Runtime PR Verification - React SPA

**Status**: ${result.status.charAt(0).toUpperCase() + result.status.slice(1)} | `;
    comment += `${reactEmoji} React ${result.firebaseConfig.buildSystem === 'vite' ? 'Vite' : 'CRA'} | `;
    comment += `${firebaseEmoji} Firebase ${result.firebaseConfig.target}\n\n`;

    // Test summary
    comment += `**Test Results**: ${result.passedTests}/${result.totalTests} passed`;
    if (result.failedTests > 0) {
      comment += ` â€¢ ${result.failedTests} failed`;
    }
    if (result.skippedTests > 0) {
      comment += ` â€¢ ${result.skippedTests} skipped`;
    }
    comment += ` â€¢ ${this.formatDuration(result.duration)}\n\n`;

    // Quick access links
    const screenshots = result.testResults.flatMap(t => t.screenshots);
    const videos = result.testResults.flatMap(t => t.videos);
    
    if (screenshots.length > 0 || videos.length > 0) {
      comment += `**Visual Evidence**: `;
      comment += `ðŸ“¸ ${screenshots.length} screenshot${screenshots.length !== 1 ? 's' : ''}`;
      if (videos.length > 0) {
        comment += ` â€¢ ðŸŽ¥ ${videos.length} video${videos.length !== 1 ? 's' : ''}`;
      }
      if (storageConsoleUrl) {
        comment += ` â€¢ [Firebase Console](${storageConsoleUrl})`;
      }
      comment += '\n\n';
    }

    // Embed screenshots directly
    if (screenshots.length > 0) {
      comment += this.generateEmbeddedScreenshots(screenshots);
    }


    // Expandable details section
    comment += '<details>\n<summary><strong>View Detailed Results</strong></summary>\n\n';

    // Components and routes verified
    if (result.summary.componentsVerified.length > 0 || result.summary.routesTested.length > 0) {
      comment += '### âœ… React App Verification\n\n';
      
      if (result.summary.componentsVerified.length > 0) {
        comment += `**Components Tested**: ${result.summary.componentsVerified.join(', ')}\n\n`;
      }
      
      if (result.summary.routesTested.length > 0) {
        comment += `**Routes Verified**: ${result.summary.routesTested.join(', ')}\n\n`;
      }
    }

    // Individual test results
    comment += '### ðŸ“‹ Test Results\n\n';
    
    for (const test of result.testResults) {
      const testEmoji = test.status === 'passed' ? 'âœ…' : test.status === 'failed' ? 'âŒ' : 'â­ï¸';
      comment += `${testEmoji} **${test.testName}** (${this.formatDuration(test.duration)})\n`;
      
      if (test.errors.length > 0) {
        comment += `   - âš ï¸ Issues: ${test.errors.slice(0, 2).join(', ')}`;
        if (test.errors.length > 2) {
          comment += ` and ${test.errors.length - 2} more`;
        }
        comment += '\n';
      }
      
      if (test.screenshots.length > 0) {
        comment += '   - ðŸ“¸ Screenshots captured for: ';
        comment += test.screenshots.map(s => s.viewport.name).join(', ') + '\n';
      }
      
      if (test.videos.length > 0 && test.videos[0]?.firebaseUrl) {
        comment += `   - ðŸŽ¥ Video: [View Recording](${test.videos[0].firebaseUrl})\n`;
      }
      
      comment += '\n';
    }

    // Issues found section
    if (result.summary.issuesFound.length > 0) {
      comment += '### âš ï¸ Issues Detected\n\n';
      for (const issue of result.summary.issuesFound.slice(0, 5)) {
        comment += `- ${issue}\n`;
      }
      if (result.summary.issuesFound.length > 5) {
        comment += `- ...and ${result.summary.issuesFound.length - 5} more issues\n`;
      }
      comment += '\n';
    }

    // Firebase configuration details
    comment += '### ðŸ”¥ Firebase Configuration\n\n';
    comment += `- **Project**: \`${result.firebaseConfig.projectId}\`\n`;
    comment += `- **Target**: \`${result.firebaseConfig.target}\`\n`;
    comment += `- **Build System**: ${result.firebaseConfig.buildSystem === 'vite' ? 'Vite' : 'Create React App'}\n`;
    comment += `- **Preview URL**: [${result.firebaseConfig.previewUrl}](${result.firebaseConfig.previewUrl})\n\n`;

    // Performance metrics
    const consoleErrors = result.testResults.flatMap(t => 
      t.consoleMessages.filter(m => m.type === 'error')
    );
    
    if (consoleErrors.length > 0) {
      comment += '### ðŸ› Console Errors\n\n';
      comment += `Found ${consoleErrors.length} console error${consoleErrors.length !== 1 ? 's' : ''} during testing:\n\n`;
      for (const error of consoleErrors.slice(0, 3)) {
        comment += `- \`${error.text.substring(0, 100)}${error.text.length > 100 ? '...' : ''}\`\n`;
      }
      if (consoleErrors.length > 3) {
        comment += `- ...and ${consoleErrors.length - 3} more errors\n`;
      }
      comment += '\n';
    }

    comment += '</details>\n\n';

    // Footer
    const timestamp = new Date().toLocaleString();
    comment += `---\n*Generated by [Runtime PR Verification](https://github.com/your-org/runtime-pr-verification) â€¢ ${timestamp}*`;

    return comment;
  }

  /**
   * Find existing comment from this action
   */
  private async findExistingComment(): Promise<{ id: number } | null> {
    try {
      const comments = await this.octokit.rest.issues.listComments({
        owner: this.owner,
        repo: this.repo,
        issue_number: this.prNumber,
        per_page: 100
      });

      // Look for comments containing our signature
      const existingComment = comments.data.find(comment => 
        comment.body?.includes('Runtime PR Verification') &&
        comment.body?.includes('Generated by') &&
        comment.user?.type === 'Bot'
      );

      return existingComment ? { id: existingComment.id } : null;
    } catch (error) {
      core.warning(`Failed to find existing comment: ${error}`);
      return null;
    }
  }

  /**
   * Format duration in human-readable format
   */
  private formatDuration(durationMs: number): string {
    if (durationMs < 1000) {
      return `${durationMs}ms`;
    } else if (durationMs < 60000) {
      return `${(durationMs / 1000).toFixed(1)}s`;
    } else {
      const minutes = Math.floor(durationMs / 60000);
      const seconds = ((durationMs % 60000) / 1000).toFixed(0);
      return `${minutes}m ${seconds}s`;
    }
  }

  /**
   * Generate embedded screenshots for PR comment
   */
  private generateEmbeddedScreenshots(screenshots: Screenshot[]): string {
    if (screenshots.length === 0) {
      return '';
    }

    let gallery = '### ðŸ“¸ Screenshots\n\n';
    
    // Group screenshots by route
    const groupedByRoute = screenshots.reduce((acc, screenshot) => {
      const route = screenshot.name.split('-').slice(0, -1).join('-') || 'home';
      if (!acc[route]) {
        acc[route] = [];
      }
      acc[route].push(screenshot);
      return acc;
    }, {} as Record<string, Screenshot[]>);

    for (const [route, routeScreenshots] of Object.entries(groupedByRoute)) {
      gallery += `#### Route: \`/${route}\`\n\n`;
      
      // Create a table for viewports
      gallery += '<table>\n<tr>\n';
      
      // Sort by viewport size (desktop, tablet, mobile)
      const sorted = routeScreenshots.sort((a, b) => b.viewport.width - a.viewport.width);
      
      for (const screenshot of sorted) {
        if (screenshot.firebaseUrl) {
          gallery += `<td align="center">\n`;
          gallery += `<strong>${screenshot.viewport.name}</strong><br>\n`;
          gallery += `${screenshot.viewport.width}Ã—${screenshot.viewport.height}<br>\n`;
          gallery += `<img src="${screenshot.firebaseUrl}" width="300" alt="${screenshot.name}">\n`;
          gallery += `</td>\n`;
        }
      }
      
      gallery += '</tr>\n</table>\n\n';
    }

    return gallery;
  }


  /**
   * Generate compact status badge for quick overview
   */
  generateStatusBadge(result: VerificationResult): string {
    const status = result.status;
    const color = status === 'success' ? 'brightgreen' : status === 'partial' ? 'yellow' : 'red';
    const tests = `${result.passedTests}/${result.totalTests}`;
    
    return `![Tests](https://img.shields.io/badge/tests-${tests}-${color}) ![Status](https://img.shields.io/badge/status-${status}-${color})`;
  }
}