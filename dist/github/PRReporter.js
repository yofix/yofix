"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PRReporter = void 0;
const core = __importStar(require("@actions/core"));
const github_1 = require("@actions/github");
class PRReporter {
    constructor(githubToken) {
        this.octokit = (0, github_1.getOctokit)(githubToken);
        const context = require('@actions/github').context;
        this.owner = context.repo.owner;
        this.repo = context.repo.repo;
        this.prNumber = context.payload.pull_request?.number;
        if (!this.prNumber) {
            throw new Error('No pull request number found in context');
        }
    }
    async postResults(result, storageConsoleUrl) {
        core.info(`Posting verification results to PR #${this.prNumber}...`);
        try {
            const comment = this.generateCommentBody(result, storageConsoleUrl);
            const existingComment = await this.findExistingComment();
            if (existingComment) {
                await this.octokit.rest.issues.updateComment({
                    owner: this.owner,
                    repo: this.repo,
                    comment_id: existingComment.id,
                    body: comment
                });
                core.info('Updated existing PR comment');
            }
            else {
                await this.octokit.rest.issues.createComment({
                    owner: this.owner,
                    repo: this.repo,
                    issue_number: this.prNumber,
                    body: comment
                });
                core.info('Created new PR comment');
            }
        }
        catch (error) {
            core.error(`Failed to post PR comment: ${error}`);
            throw error;
        }
    }
    async postStatusUpdate(status, message) {
        try {
            const statusEmoji = {
                running: '🔄',
                failed: '❌',
                skipped: '⏭️'
            };
            const comment = `## ${statusEmoji[status]} Runtime PR Verification

**Status**: ${status.charAt(0).toUpperCase() + status.slice(1)}

${message}

---
*Generated by [YoFix](https://github.com/yofix/yofix) • ${new Date().toLocaleString()}*`;
            const existingComment = await this.findExistingComment();
            if (existingComment) {
                await this.octokit.rest.issues.updateComment({
                    owner: this.owner,
                    repo: this.repo,
                    comment_id: existingComment.id,
                    body: comment
                });
            }
            else {
                await this.octokit.rest.issues.createComment({
                    owner: this.owner,
                    repo: this.repo,
                    issue_number: this.prNumber,
                    body: comment
                });
            }
        }
        catch (error) {
            core.warning(`Failed to post status update: ${error}`);
        }
    }
    generateCommentBody(result, storageConsoleUrl) {
        const statusEmoji = result.status === 'success' ? '✅' : result.status === 'partial' ? '⚠️' : '❌';
        const firebaseEmoji = '🔥';
        const reactEmoji = '⚛️';
        let comment = `## ${statusEmoji} Runtime PR Verification - React SPA

**Status**: ${result.status.charAt(0).toUpperCase() + result.status.slice(1)} | `;
        comment += `${reactEmoji} React ${result.firebaseConfig.buildSystem === 'vite' ? 'Vite' : 'CRA'} | `;
        comment += `${firebaseEmoji} Firebase ${result.firebaseConfig.target}\n\n`;
        comment += `**Test Results**: ${result.passedTests}/${result.totalTests} passed`;
        if (result.failedTests > 0) {
            comment += ` • ${result.failedTests} failed`;
        }
        if (result.skippedTests > 0) {
            comment += ` • ${result.skippedTests} skipped`;
        }
        comment += ` • ${this.formatDuration(result.duration)}\n\n`;
        const screenshots = result.testResults.flatMap(t => t.screenshots);
        const videos = result.testResults.flatMap(t => t.videos);
        if (screenshots.length > 0 || videos.length > 0) {
            comment += `**Visual Evidence**: `;
            comment += `📸 ${screenshots.length} screenshot${screenshots.length !== 1 ? 's' : ''}`;
            if (videos.length > 0) {
                comment += ` • 🎥 ${videos.length} video${videos.length !== 1 ? 's' : ''}`;
            }
            if (storageConsoleUrl) {
                comment += ` • [Firebase Console](${storageConsoleUrl})`;
            }
            comment += '\n\n';
        }
        if (screenshots.length > 0) {
            core.info(`Embedding ${screenshots.length} screenshots in PR comment`);
            const screenshotsWithUrls = screenshots.filter(s => s.firebaseUrl);
            core.info(`Screenshots with Firebase URLs: ${screenshotsWithUrls.length}`);
            comment += this.generateEmbeddedScreenshots(screenshots);
        }
        if (videos.length > 0) {
            core.info(`Embedding ${videos.length} videos in PR comment`);
            const videosWithUrls = videos.filter(v => v.firebaseUrl);
            core.info(`Videos with Firebase URLs: ${videosWithUrls.length}`);
            comment += this.generateEmbeddedVideos(videos);
        }
        comment += '<details>\n<summary><strong>View Detailed Results</strong></summary>\n\n';
        if (result.summary.componentsVerified.length > 0 || result.summary.routesTested.length > 0) {
            comment += '### ✅ React App Verification\n\n';
            if (result.summary.componentsVerified.length > 0) {
                comment += `**Components Tested**: ${result.summary.componentsVerified.join(', ')}\n\n`;
            }
            if (result.summary.routesTested.length > 0) {
                comment += `**Routes Verified**: ${result.summary.routesTested.join(', ')}\n\n`;
            }
        }
        comment += '### 📋 Test Results\n\n';
        for (const test of result.testResults) {
            const testEmoji = test.status === 'passed' ? '✅' : test.status === 'failed' ? '❌' : '⏭️';
            comment += `${testEmoji} **${test.testName}** (${this.formatDuration(test.duration)})\n`;
            if (test.errors.length > 0) {
                comment += `   - ⚠️ Issues: ${test.errors.slice(0, 2).join(', ')}`;
                if (test.errors.length > 2) {
                    comment += ` and ${test.errors.length - 2} more`;
                }
                comment += '\n';
            }
            if (test.screenshots.length > 0) {
                comment += '   - 📸 Screenshots captured for: ';
                comment += test.screenshots.map(s => s.viewport.name).join(', ') + '\n';
            }
            if (test.videos.length > 0 && test.videos[0]?.firebaseUrl) {
                comment += `   - 🎥 Video: [View Recording](${test.videos[0].firebaseUrl})\n`;
            }
            comment += '\n';
        }
        if (result.summary.issuesFound.length > 0) {
            comment += '### ⚠️ Issues Detected\n\n';
            for (const issue of result.summary.issuesFound.slice(0, 5)) {
                comment += `- ${issue}\n`;
            }
            if (result.summary.issuesFound.length > 5) {
                comment += `- ...and ${result.summary.issuesFound.length - 5} more issues\n`;
            }
            comment += '\n';
        }
        comment += '### 🔥 Firebase Configuration\n\n';
        comment += `- **Project**: \`${result.firebaseConfig.projectId}\`\n`;
        comment += `- **Target**: \`${result.firebaseConfig.target}\`\n`;
        comment += `- **Build System**: ${result.firebaseConfig.buildSystem === 'vite' ? 'Vite' : 'Create React App'}\n`;
        comment += `- **Preview URL**: [${result.firebaseConfig.previewUrl}](${result.firebaseConfig.previewUrl})\n\n`;
        const consoleErrors = result.testResults.flatMap(t => t.consoleMessages.filter(m => m.type === 'error'));
        if (consoleErrors.length > 0) {
            comment += '### 🐛 Console Errors\n\n';
            comment += `Found ${consoleErrors.length} console error${consoleErrors.length !== 1 ? 's' : ''} during testing:\n\n`;
            for (const error of consoleErrors.slice(0, 3)) {
                comment += `- \`${error.text.substring(0, 100)}${error.text.length > 100 ? '...' : ''}\`\n`;
            }
            if (consoleErrors.length > 3) {
                comment += `- ...and ${consoleErrors.length - 3} more errors\n`;
            }
            comment += '\n';
        }
        comment += '</details>\n\n';
        const timestamp = new Date().toLocaleString();
        comment += `---\n*Generated by [YoFix](https://github.com/yofix/yofix) • ${timestamp}*`;
        return comment;
    }
    async findExistingComment() {
        try {
            const comments = await this.octokit.rest.issues.listComments({
                owner: this.owner,
                repo: this.repo,
                issue_number: this.prNumber,
                per_page: 100
            });
            const existingComment = comments.data.find(comment => comment.body?.includes('Runtime PR Verification') &&
                comment.body?.includes('Generated by') &&
                comment.user?.type === 'Bot');
            return existingComment ? { id: existingComment.id } : null;
        }
        catch (error) {
            core.warning(`Failed to find existing comment: ${error}`);
            return null;
        }
    }
    formatDuration(durationMs) {
        if (durationMs < 1000) {
            return `${durationMs}ms`;
        }
        else if (durationMs < 60000) {
            return `${(durationMs / 1000).toFixed(1)}s`;
        }
        else {
            const minutes = Math.floor(durationMs / 60000);
            const seconds = ((durationMs % 60000) / 1000).toFixed(0);
            return `${minutes}m ${seconds}s`;
        }
    }
    generateEmbeddedScreenshots(screenshots) {
        if (screenshots.length === 0) {
            return '';
        }
        let gallery = '### 📸 Screenshots\n\n';
        const groupedByRoute = screenshots.reduce((acc, screenshot) => {
            let route = screenshot.name;
            route = route.replace(/-\d+x\d+$/, '');
            route = route.replace(/^\//, '').replace(/-/g, ' ');
            if (!acc[route]) {
                acc[route] = [];
            }
            acc[route].push(screenshot);
            return acc;
        }, {});
        for (const [route, routeScreenshots] of Object.entries(groupedByRoute)) {
            gallery += `#### Route: \`${route}\`\n\n`;
            const screenshotsWithUrls = routeScreenshots.filter(s => s.firebaseUrl);
            if (screenshotsWithUrls.length === 0) {
                gallery += `_Screenshots captured but URLs not available_\n\n`;
                continue;
            }
            gallery += '<table>\n<tr>\n';
            const sorted = screenshotsWithUrls.sort((a, b) => b.viewport.width - a.viewport.width);
            for (const screenshot of sorted) {
                gallery += `<td align="center">\n`;
                gallery += `<strong>${screenshot.viewport.name}</strong><br>\n`;
                gallery += `${screenshot.viewport.width}×${screenshot.viewport.height}<br>\n`;
                gallery += `<img src="${screenshot.firebaseUrl}" width="300" alt="${screenshot.name}" />\n`;
                gallery += `</td>\n`;
            }
            gallery += '</tr>\n</table>\n\n';
        }
        return gallery;
    }
    generateEmbeddedVideos(videos) {
        if (videos.length === 0) {
            return '';
        }
        let gallery = '### 🎥 Test Videos\n\n';
        const videosWithUrls = videos.filter(v => v.firebaseUrl);
        if (videosWithUrls.length === 0) {
            gallery += '_Videos captured but URLs not available_\n\n';
            return gallery;
        }
        gallery += '<table>\n';
        for (let i = 0; i < videosWithUrls.length; i += 3) {
            gallery += '<tr>\n';
            for (let j = i; j < Math.min(i + 3, videosWithUrls.length); j++) {
                const video = videosWithUrls[j];
                gallery += `<td align="center" width="33%">\n`;
                gallery += `<a href="${video.firebaseUrl}">\n`;
                gallery += `<div>🎬</div>\n`;
                gallery += `<strong>${video.name.replace(/\.(webm|mp4)$/, '')}</strong><br>\n`;
                gallery += `<em>${this.formatDuration(video.duration)}</em><br>\n`;
                gallery += `<kbd>▶️ Click to Play</kbd>\n`;
                gallery += `</a>\n`;
                gallery += `</td>\n`;
            }
            for (let k = videosWithUrls.length % 3; k < 3 && k > 0 && i + 3 > videosWithUrls.length; k++) {
                gallery += `<td></td>\n`;
            }
            gallery += '</tr>\n';
        }
        gallery += '</table>\n\n';
        gallery += '<details>\n<summary>Direct video links</summary>\n\n';
        for (const video of videosWithUrls) {
            gallery += `- [${video.name}](${video.firebaseUrl}) - ${this.formatDuration(video.duration)}\n`;
        }
        gallery += '\n</details>\n\n';
        return gallery;
    }
    generateStatusBadge(result) {
        const status = result.status;
        const color = status === 'success' ? 'brightgreen' : status === 'partial' ? 'yellow' : 'red';
        const tests = `${result.passedTests}/${result.totalTests}`;
        return `![Tests](https://img.shields.io/badge/tests-${tests}-${color}) ![Status](https://img.shields.io/badge/status-${status}-${color})`;
    }
}
exports.PRReporter = PRReporter;
